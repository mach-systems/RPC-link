/*
 * autotalks.cpp
 *
 *  Created on: Dec 22, 2021
 *      Author: karel
 */

#include "autotalks.hpp"

#include <pthread.h>
#include <iostream>
#include <unistd.h>

#include "autotalksLink.hpp"
#include "defs.hpp"
#include "relay.hpp"

#define RX_NON_SECURED		1	/* Dummy CAM without security */
#define RX_SECURED			2	/* Dummy CAM encapsulated in a secure packet */
#define RX_TRAFFIC_TYPE		RX_NON_SECURED


/*
 * V2X reception thread function.
 */
static void* v2x_rx_thread_entry(void * arg);

// CBR thread function
static void* v2x_cbr_thread_entry(void* arg);

/*
 * Flag to tell the communication thread to end
 */
static bool endCommThread = false;

/*
 * Flag to tell the CBR thread to end
 */
static bool endCbrThread = false;

// Reception thread identifier
static pthread_t v2x_rx_thread;

// CBR thread identifier
static pthread_t v2x_cbr_thread;



int v2x_device_init(void)
{
    (void) printf("Device initialization done\n");
    return 0;
}

void SetThreadEnd(void)
{
    endCommThread = endCbrThread = true;  // Send signal for threads to wrap it up
}

int autotalks_device_deinit(void)
{
    SetThreadEnd();
    (void) pthread_join(v2x_rx_thread, NULL);  // Wait for reception thread
    (void) pthread_join(v2x_cbr_thread, NULL); // Wait for CBR thread end
    return EXIT_SUCCESS;
}

static void* v2x_rx_thread_entry(void * arg)
{
    AutotalksLink* link = (AutotalksLink*) arg;
    while (!endCommThread)
    {
        sleep(1);
        // endCommThread check - prevent hanging because of KJ
        if ((nullptr != link) && !endCommThread)
        {
            V2xFrame frame;
            frame.WlanParameters.Priority = 3;
            frame.SrcAddress = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
            frame.DstAddress = {0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b};
#if RX_TRAFFIC_TYPE == RX_NON_SECURED
            // Non-secured data
            frame.Data = {
                0x11, 0x00, 0x05, 0x01, 0x20, 0x50, 0x02, 0x80, 0x00, 0x2f, 0x01, 0x00, 0x80, 0x00, 0x4e, 0x31,
                0xb9, 0x42, 0x42, 0xa6, 0x46, 0xbd, 0x29, 0x84, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xd1, 0x00, 0x00, 0x02, 0x02, 0xe4, 0x41,
                0xc1, 0x03, 0x2c, 0x8f, 0x40, 0x5d, 0x69, 0x3a, 0x40, 0x3a, 0xd2, 0x74, 0x80, 0x3f, 0xff, 0xff,
                0xfc, 0x23, 0xb7, 0x74, 0x3e, 0x00, 0xe1, 0x1f, 0xdf, 0xff, 0xfe, 0xbf, 0xd1, 0xe5, 0x04, 0x03,
                0xff, 0xe3, 0xff, 0xf4, 0x00, 0x00, 0x00
            };
#elif RX_TRAFFIC_TYPE == RX_SECURED
            // Secured data
            frame.Data = {
                0x12, 0x00, 0x05, 0x01, 0x03, 0x81, 0x00, 0x40, 0x03, 0x80, 0x53, 0x20, 0x50, 0x02, 0x80, 0x00,
                0x2f, 0x01, 0x00, 0x80, 0x00, 0x52, 0xb0, 0xca, 0xa5, 0x20, 0x39, 0x40, 0x27, 0x50, 0xe8, 0x80,
                0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
                0xd1, 0x00, 0x00, 0x02, 0x02, 0x1c, 0x16, 0xea, 0xa0, 0x54, 0xc8, 0x40, 0x5d, 0x69, 0x3a, 0x40,
                0x3a, 0xd2, 0x74, 0x80, 0x3f, 0xff, 0xff, 0xfc, 0x23, 0xb7, 0x74, 0x3e, 0x00, 0xe1, 0x1f, 0xdf,
                0xff, 0xfe, 0xbf, 0xd1, 0xe5, 0x04, 0x03, 0xff, 0xe3, 0xff, 0xf4, 0x00, 0x00, 0x00, 0x40, 0x01,
                0x24, 0x00, 0x02, 0x62, 0x5a, 0x99, 0xa3, 0x2d, 0xff, 0x81, 0x01, 0x01, 0x80, 0x03, 0x00, 0x80,
                0x75, 0xcf, 0xab, 0x60, 0x47, 0x3b, 0xd6, 0x04, 0x10, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27,
                0xff, 0xfb, 0xf2, 0x84, 0x00, 0x17, 0x01, 0x04, 0x80, 0x01, 0x24, 0x80, 0x03, 0x01, 0x00, 0x00,
                0x80, 0x01, 0x25, 0x80, 0x04, 0x01, 0xff, 0xff, 0xff, 0x80, 0x01, 0x8d, 0x80, 0x00, 0x80, 0x04,
                0x10, 0x20, 0x40, 0x7e, 0x80, 0x00, 0x80, 0x80, 0x84, 0x88, 0xee, 0xf1, 0x2d, 0x5b, 0x25, 0x51,
                0x86, 0x48, 0x84, 0xd0, 0x30, 0xdf, 0x8b, 0x8a, 0x73, 0x2d, 0xcc, 0x6c, 0xcd, 0x64, 0x3b, 0x8b,
                0xa5, 0xe1, 0x3f, 0xb9, 0x8c, 0x2d, 0xec, 0x77, 0x00, 0x81, 0x6f, 0x94, 0x7e, 0xeb, 0xd0, 0x9a,
                0x20, 0xc4, 0xa0, 0x7b, 0xcc, 0x8a, 0x66, 0x3c, 0xe4, 0xda, 0x63, 0x59, 0x65, 0x36, 0x20, 0xa6,
                0x86, 0x3b, 0x8b, 0x40, 0xe5, 0xdb, 0xc5, 0xb8, 0xa0, 0x80, 0x80, 0xa0, 0x37, 0x03, 0x22, 0x8a,
                0xff, 0x93, 0x23, 0x2b, 0xb9, 0x6d, 0xea, 0xca, 0xe7, 0x72, 0x2c, 0x4e, 0xda, 0x62, 0x8b, 0xe0,
                0x53, 0xdf, 0x93, 0xdb, 0x8b, 0x1c, 0x0c, 0xf3, 0xee, 0x48, 0xbc, 0xa1, 0x4c, 0x99, 0x1a, 0xa3,
                0x95, 0x2b, 0x1f, 0x40, 0x7d, 0x58, 0x19, 0xcf, 0xc1, 0x3a, 0xb5, 0x7d, 0x95, 0x82, 0xc5, 0xd8,
                0x7d, 0xc5, 0xcc, 0xf2, 0xe0, 0xf5, 0xbb, 0x38, 0xca, 0x18, 0x6f, 0x80, 0x80, 0x84, 0xe0, 0x38,
                0xc5, 0x47, 0x57, 0xbd, 0xaa, 0x38, 0x78, 0x74, 0xac, 0x14, 0x1a, 0x3e, 0xac, 0x13, 0xd2, 0xc1,
                0xbe, 0x61, 0x27, 0x5a, 0x51, 0x98, 0x47, 0x41, 0xb0, 0xa0, 0xf9, 0x51, 0xd6, 0x76, 0x83, 0x55,
                0x0e, 0xf0, 0x02, 0x19, 0xe6, 0x1a, 0xa9, 0x00, 0xf1, 0x46, 0x0e, 0xeb, 0x2c, 0xf0, 0x88, 0x4d,
                0xcf, 0x17, 0xd6, 0x2f, 0x90, 0xc8, 0xb3, 0x3a, 0xc5, 0x3e, 0xf5, 0x3f, 0x99
            };
#else
            frame.Data = {
            	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
				0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
            };
#endif /* */
            frame.WlanParameters.Power = -10;
            frame.WlanParameters.Datarate = 5;
            static uint64_t timestamp = 0;
            timestamp += 1000000;
            frame.Timestamp = timestamp;
            link->data_received(frame);
        }
    }
    return NULL;
}

void initRxThread(AutotalksLink* pLinkLayer)
{
    // Create new thread as Autotalks API does not have asynchronous callbacks
    int rv = pthread_create(&v2x_rx_thread, NULL, v2x_rx_thread_entry, (void*) pLinkLayer);
    if (0 != rv)
    {
        (void) fprintf(stderr, "V2X rx pthread_create failed with %s\n", strerror(rv));
    }
    (void) printf("V2X rx pthread_create success.\n");
}

void initCbrThread(AutotalksLink* pLinkLayer)
{
    int rv = pthread_create(&v2x_cbr_thread, NULL, v2x_cbr_thread_entry, (void*) pLinkLayer);
    if (0 != rv)
    {
        (void) fprintf(stderr, "CBR pthread_create failed with %s\n", strerror(rv));
    }
    (void) printf("CBR pthread_create success.\n");
}

static void* v2x_cbr_thread_entry(void* arg)
{
    AutotalksLink* link = (AutotalksLink*) arg;
    while (!endCbrThread)
    {
        sleep(1);
        int32_t cbr = 50;
        if (nullptr != link && !endCbrThread)
        {
            link->DccMeasuredCallback(((double) cbr) / 100.0);
        }
    }
    return NULL;
}

void autotalksTransmit(const V2xFrame& frame)
{
    (void) frame;
    // Fill the transmission parameters from the frame
    static uint32_t id = 0;
    std::cout << ("Real sending #" + std::to_string(id++)) << std::endl;
}

bool SetAddress(const std::vector<uint8_t>& address)
{
    std::cout << "Set address ";
    for (auto & i : address)
    {
        std::cout << (unsigned) i << " ";;
    }
    std::cout << std::endl;
    return true;
}
